{"version":3,"sources":["webpack:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js","webpack:///./node_modules/register-service-worker/index.js","webpack:///./node_modules/vuex-persist/dist/esm/index.js"],"names":["normalizeComponent","scriptExports","render","staticRenderFns","functionalTemplate","injectStyles","scopeId","moduleIdentifier","shadowMode","hook","options","_compiled","functional","_scopeId","context","this","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","_injectStyles","originalRender","h","existing","beforeCreate","concat","exports","__webpack_require__","d","__webpack_exports__","register","isLocalhost","Boolean","window","location","hostname","match","swUrl","hooks","emit","args","len","arguments","length","apply","navigator","addEventListener","checkValidServiceWorker","serviceWorker","ready","then","registration","registerValidSW","waiting","onupdatefound","installingWorker","installing","onstatechange","state","controller","catch","error","fetch","response","status","headers","get","indexOf","Error","unregister","onLine","lodash_merge__WEBPACK_IMPORTED_MODULE_0__","lodash_merge__WEBPACK_IMPORTED_MODULE_0___default","n","MockStorage","Object","keys","[object Object]","index","key","data","toString","SimplePromiseQueue","_queue","_flushing","promise","push","Promise","resolve","flushQueue","chain","nextTask","shift","merge","into","from","CircularJSON","JSON","VuexPersistence","_mutex","subscriber","store","handler","subscribe","subscribed","supportCircular","storage","localStorage","reducer","modules","reduce","a","i","filter","mutation","strictMode","RESTORE_MUTATION","savedState","mergedState","propertyName","_vm","$set","asyncStorage","storageConfig","_config","name","restoreState","getItem","value","parse","saveState","setItem","stringify","plugin","commit","replaceState","enqueue"],"mappings":"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","file":"js/chunk-vendors~678f84af.9e84764b.js","sourcesContent":["/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n","// Register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\nvar isLocalhost = function () { return Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n); }\n\nexport function register (swUrl, hooks) {\n  var emit = function (hook) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    if (hooks && hooks[hook]) {\n      hooks[hook].apply(hooks, args)\n    }\n  }\n\n  if ('serviceWorker' in navigator) {\n    window.addEventListener('load', function () {\n      if (isLocalhost()) {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, emit)\n        navigator.serviceWorker.ready.then(function (registration) {\n          emit('ready', registration)\n        })\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, emit)\n      }\n    })\n  }\n}\n\nfunction registerValidSW (swUrl, emit) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(function (registration) {\n      emit('registered', registration)\n      if (registration.waiting) {\n        emit('updated', registration)\n        return\n      }\n      registration.onupdatefound = function () {\n        emit('updatefound', registration)\n        var installingWorker = registration.installing\n        installingWorker.onstatechange = function () {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              emit('updated', registration)\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              emit('cached', registration)\n            }\n          }\n        }\n      }\n    })\n    .catch(function (error) {\n      emit('error', error)\n    })\n}\n\nfunction checkValidServiceWorker (swUrl, emit) {\n  // Check if the service worker can be found.\n  fetch(swUrl)\n    .then(function (response) {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found.\n        emit('error', new Error((\"Service worker not found at \" + swUrl)))\n        unregister()\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, emit)\n      }\n    })\n    .catch(function (error) {\n      if (!navigator.onLine) {\n        emit('offline')\n      } else {\n        emit('error', error)\n      }\n    })\n}\n\nexport function unregister () {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(function (registration) {\n      registration.unregister()\n    })\n  }\n}\n","import lodashMerge from 'lodash.merge';\n\n/**\r\n * Created by championswimmer on 22/07/17.\r\n */\r\nlet MockStorage;\r\n// @ts-ignore\r\n{\r\n    MockStorage = class {\r\n        get length() {\r\n            return Object.keys(this).length;\r\n        }\r\n        key(index) {\r\n            return Object.keys(this)[index];\r\n        }\r\n        setItem(key, data) {\r\n            this[key] = data.toString();\r\n        }\r\n        getItem(key) {\r\n            return this[key];\r\n        }\r\n        removeItem(key) {\r\n            delete this[key];\r\n        }\r\n        clear() {\r\n            for (const key of Object.keys(this)) {\r\n                delete this[key];\r\n            }\r\n        }\r\n    };\r\n}\n\n// tslint:disable: variable-name\r\nclass SimplePromiseQueue {\r\n    constructor() {\r\n        this._queue = [];\r\n        this._flushing = false;\r\n    }\r\n    enqueue(promise) {\r\n        this._queue.push(promise);\r\n        if (!this._flushing) {\r\n            return this.flushQueue();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    flushQueue() {\r\n        this._flushing = true;\r\n        const chain = () => {\r\n            const nextTask = this._queue.shift();\r\n            if (nextTask) {\r\n                return nextTask.then(chain);\r\n            }\r\n            else {\r\n                this._flushing = false;\r\n            }\r\n        };\r\n        return Promise.resolve(chain());\r\n    }\r\n}\n\nfunction merge(into, from) {\r\n    return lodashMerge({}, into, from);\r\n}\n\nlet CircularJSON = JSON;\r\n/**\r\n * A class that implements the vuex persistence.\r\n * @type S type of the 'state' inside the store (default: any)\r\n */\r\nclass VuexPersistence {\r\n    /**\r\n     * Create a {@link VuexPersistence} object.\r\n     * Use the <code>plugin</code> function of this class as a\r\n     * Vuex plugin.\r\n     * @param {PersistOptions} options\r\n     */\r\n    constructor(options) {\r\n        // tslint:disable-next-line:variable-name\r\n        this._mutex = new SimplePromiseQueue();\r\n        /**\r\n         * Creates a subscriber on the store. automatically is used\r\n         * when this is used a vuex plugin. Not for manual usage.\r\n         * @param store\r\n         */\r\n        this.subscriber = (store) => (handler) => store.subscribe(handler);\r\n        if (typeof options === 'undefined')\r\n            options = {};\r\n        this.key = ((options.key != null) ? options.key : 'vuex');\r\n        this.subscribed = false;\r\n        this.supportCircular = options.supportCircular || false;\r\n        if (this.supportCircular) {\r\n            CircularJSON = require('circular-json');\r\n        }\r\n        // @ts-ignore\r\n        if (process.env.NODE_ENV === 'production') {\r\n            this.storage = options.storage || window.localStorage;\r\n        }\r\n        else {\r\n            // @ts-ignore\r\n            {\r\n                this.storage = options.storage || (typeof window !== 'undefined' ? window.localStorage : new MockStorage());\r\n            }\r\n        }\r\n        /**\r\n         * How this works is -\r\n         *  1. If there is options.reducer function, we use that, if not;\r\n         *  2. We check options.modules;\r\n         *    1. If there is no options.modules array, we use entire state in reducer\r\n         *    2. Otherwise, we create a reducer that merges all those state modules that are\r\n         *        defined in the options.modules[] array\r\n         * @type {((state: S) => {}) | ((state: S) => S) | ((state: any) => {})}\r\n         */\r\n        this.reducer = ((options.reducer != null)\r\n            ? options.reducer\r\n            : ((options.modules == null)\r\n                ? ((state) => state)\r\n                : ((state) => options.modules.reduce((a, i) => merge(a, { [i]: state[i] }), { /* start empty accumulator*/}))));\r\n        this.filter = options.filter || ((mutation) => true);\r\n        this.strictMode = options.strictMode || false;\r\n        this.RESTORE_MUTATION = function RESTORE_MUTATION(state, savedState) {\r\n            const mergedState = merge(state, savedState || {});\r\n            for (const propertyName of Object.keys(mergedState)) {\r\n                this._vm.$set(state, propertyName, mergedState[propertyName]);\r\n            }\r\n        };\r\n        this.asyncStorage = options.asyncStorage || false;\r\n        const storageConfig = this.storage && (this.storage)._config;\r\n        this.asyncStorage = this.asyncStorage || (storageConfig && storageConfig.name) === 'localforage';\r\n        if (this.asyncStorage) {\r\n            /**\r\n             * Async {@link #VuexPersistence.restoreState} implementation\r\n             * @type {((key: string, storage?: Storage) =>\r\n             *      (Promise<S> | S)) | ((key: string, storage: AsyncStorage) => Promise<any>)}\r\n             */\r\n            this.restoreState = ((options.restoreState != null)\r\n                ? options.restoreState\r\n                : ((key, storage) => (storage).getItem(key)\r\n                    .then((value) => typeof value === 'string' // If string, parse, or else, just return\r\n                    ? (this.supportCircular\r\n                        ? CircularJSON.parse(value || '{}')\r\n                        : JSON.parse(value || '{}'))\r\n                    : (value || {}))));\r\n            /**\r\n             * Async {@link #VuexPersistence.saveState} implementation\r\n             * @type {((key: string, state: {}, storage?: Storage) =>\r\n             *    (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n             */\r\n            this.saveState = ((options.saveState != null)\r\n                ? options.saveState\r\n                : ((key, state, storage) => (storage).setItem(key, // Second argument is state _object_ if localforage, stringified otherwise\r\n                (((storage && storage._config && storage._config.name) === 'localforage')\r\n                    ? merge({}, state || {})\r\n                    : (this.supportCircular\r\n                        ? CircularJSON.stringify(state)\r\n                        : JSON.stringify(state))))));\r\n            /**\r\n             * Async version of plugin\r\n             * @param {Store<S>} store\r\n             */\r\n            this.plugin = (store) => {\r\n                (this.restoreState(this.key, this.storage)).then((savedState) => {\r\n                    /**\r\n                     * If in strict mode, do only via mutation\r\n                     */\r\n                    if (this.strictMode) {\r\n                        store.commit('RESTORE_MUTATION', savedState);\r\n                    }\r\n                    else {\r\n                        store.replaceState(merge(store.state, savedState || {}));\r\n                    }\r\n                    this.subscriber(store)((mutation, state) => {\r\n                        if (this.filter(mutation)) {\r\n                            this._mutex.enqueue(this.saveState(this.key, this.reducer(state), this.storage));\r\n                        }\r\n                    });\r\n                    this.subscribed = true;\r\n                });\r\n            };\r\n        }\r\n        else {\r\n            /**\r\n             * Sync {@link #VuexPersistence.restoreState} implementation\r\n             * @type {((key: string, storage?: Storage) =>\r\n             *    (Promise<S> | S)) | ((key: string, storage: Storage) => (any | string | {}))}\r\n             */\r\n            this.restoreState = ((options.restoreState != null)\r\n                ? options.restoreState\r\n                : ((key, storage) => {\r\n                    const value = (storage).getItem(key);\r\n                    if (typeof value === 'string') { // If string, parse, or else, just return\r\n                        return (this.supportCircular\r\n                            ? CircularJSON.parse(value || '{}')\r\n                            : JSON.parse(value || '{}'));\r\n                    }\r\n                    else {\r\n                        return (value || {});\r\n                    }\r\n                }));\r\n            /**\r\n             * Sync {@link #VuexPersistence.saveState} implementation\r\n             * @type {((key: string, state: {}, storage?: Storage) =>\r\n             *     (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n             */\r\n            this.saveState = ((options.saveState != null)\r\n                ? options.saveState\r\n                : ((key, state, storage) => (storage).setItem(key, // Second argument is state _object_ if localforage, stringified otherwise\r\n                (this.supportCircular\r\n                    ? CircularJSON.stringify(state)\r\n                    : JSON.stringify(state)))));\r\n            /**\r\n             * Sync version of plugin\r\n             * @param {Store<S>} store\r\n             */\r\n            this.plugin = (store) => {\r\n                const savedState = this.restoreState(this.key, this.storage);\r\n                if (this.strictMode) {\r\n                    store.commit('RESTORE_MUTATION', savedState);\r\n                }\r\n                else {\r\n                    store.replaceState(merge(store.state, savedState || {}));\r\n                }\r\n                this.subscriber(store)((mutation, state) => {\r\n                    if (this.filter(mutation)) {\r\n                        this.saveState(this.key, this.reducer(state), this.storage);\r\n                    }\r\n                });\r\n                this.subscribed = true;\r\n            };\r\n        }\r\n    }\r\n}\n\nexport default VuexPersistence;\nexport { VuexPersistence, MockStorage };\n//# sourceMappingURL=index.js.map\n"],"sourceRoot":""}